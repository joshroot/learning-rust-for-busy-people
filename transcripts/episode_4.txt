Podcast: Learning Rust For Busy People
Episode: #4 – Extracting text from a Markdown file, part 2
Date: Monday February 16, 2026

Hello everyone! Welcome to the "Learning Rust For Busy People" podcast! This podcast is for busy people who want to learn and quickly be productive with the Rust programming language.

My name is Josh and today I’ll focus on the second part of our discussion about the topic of extracting text from a Markdown file.

In the previous episode, I talked about version 1 of the practical code example for this topic, which was the bare minimum working version. Today, I’ll discuss version 2 of the code which will resolve two specific limitations in the previous version of the code and which will introduce us to the concept of "ownership".

The first limitation we’ll address is the project structure. To follow best practices for how to organize a Rust project, we’ll refactor the code into two separate files which are "main.rs" and "lib.rs". Both of these files reside in the "src" subdirectory. "main.rs" is referred to as a "binary crate" and "lib.rs" is referred to as a "library crate".

You might be wondering, why do we need to structure our project this way? The simple reason is – "separation of concerns". What are the concerns we’re separating? Well, some of our code runs the program itself, and other parts of our code handle the logic. Separating the code into a binary crate that is responsible for running the program, and a library crate that is responsible for all of the logic, is a much cleaner approach than keeping all this code in a single file.

This approach has several critical advantages such as preventing the "main" function from growing too large and complex, preventing our binary crate from growing too large, and enabling us to write tests for the logic in the library crate. A detailed explanation of the separation of concerns is provided in the book, "The Rust Programming Language", in the chapter titled "An I/O Project: Building a Command Line Program".

The second limitation we’ll address is the hard-coded file path for the Markdown file. Currently, our program does not generalize. If we want to run this program for other Markdown files then we need to manually change the hard-coded file path. That’s really inefficient. Instead of a hard-coded value, we’ll provide the path to the Markdown file as a command-line argument when we run the program.

Let’s dive in to the code that addresses these limitations. In this version of the code, we have a separate "main.rs" file and "lib.rs" file. In "main.rs", we still have a single function called "main". In "lib.rs", we have a single function called "run". All of the statements that were originally in the body of the "main" function are now in the body of the "run" function. By moving these statements out of the "main" function and into the "run" function, we effectively moved our program logic out of the binary crate and into the library crate. The "run" function is called by the "main" function. Program execution begins with the "main" function, so that means that "main.rs" (which is where the "main" function resides) handles the running of our program. With these changes, we’ve achieved the separation of concerns we talked about earlier.

Coming from a background in Python programming, I’ve seen many different approaches to addressing the general problem of "separation of concerns". There are different approaches to naming files, organizing files within subdirectories, and deciding where to put code that handles running the program versus where to put code that handles program logic. This flexibility can be a good thing, but with it comes additional burden on developers because we need to spend time and energy on understanding the nuances for different ways in which Python codebases are structured.

Over time, I’ve become a lot more intentional about how to structure a Python project to ensure that it’s well organized, can be easily maintained and tested, and can be easily understood by other developers. Despite that, I’ve still noticed undesirable levels of variation in the approaches I’ve taken.

With Rust, the project structure feels more standardized and tightened up, right from the start. I know that currently we’re talking through a very simple codebase and that complexity will ramp up with more advanced projects, so I’m eager to see if the feeling I have at this moment holds up over time. This is an open question I’ll keep in mind.

Let’s jump back into the code. There’s something different between the "run" function and the "main" function. For the "run" function, there’s an additional keyword in front of the "fn" keyword. This additional keyword is "pub", spelled "p-u-b". This is used to declare the function "run" as "public", which means we’re making this part of the library crate’s public API so that it’s accessible by the binary crate. When we put this all together, the line where the "run" function is defined begins with "pub fn run".

Now let’s move on to generalizing our code so that we provide the path to the Markdown file as a command-line argument instead of as a hard-coded value. The Rust standard library has functionality that allows us to read the values of command-line arguments. To access this functionality, we need to bring the "env" module into scope via a "use" statement at the top of "main.rs". This statement reads "use std::env;".

Then, at the beginning of the "main" function, we have a statement that reads "let args: Vec<String> = ", "env", immediately followed by two colons and then the function name "args". The function "args" has no parameters, so it’s followed by an empty set of parentheses. The return value of the "args" function is an iterator over the arguments passed to the program, where each iterator element is a "String" value ("String" with a capital "S"). On the same line, we then have ".collect", followed by an empty set of parentheses to call the "collect" method, which converts the iterator into a vector of String values.

This statement requires a type annotation after the variable name to indicate what kind of collection we’re creating. After the variable name "args", we have a colon and then the type annotation that reads "Vec<String>". The book indicates that a type annotation is often needed when using the "collect" method since this method can be used to create different kinds of collections.

On the next line in the "main" function, we have a new statement that reads "dbg!" with "&args" inside parentheses. Since the name "dbg" is followed by an exclamation point, we know that this statement is calling the "dbg!" macro, as opposed to a function named "dbg". The "dbg!" macro is useful for printing information about a variable, which includes the name of the file and the line number where the macro is called, as well as the value of the variable that is passed to the macro. The "dbg!" macro prints to standard error instead of to standard output, so using this macro helps keep debugging-related information separate from what is printed with the "println!" macro.

So what’s going on with the ampersand symbol in the argument that we passed to the "dbg!" macro? Why did we pass "&args" instead of just "args"? Well, this brings us to an important concept in the land of Rust, which is the concept of "ownership". In fact, the concept of "ownership" is so important that the book describes it as the most unique feature in Rust.

Rust programs, like programs written in other programming languages, need to manage the memory they use. In some programming languages, memory management is handled by explicitly allocating and freeing memory. Other languages use a garbage collector to free up memory that is no longer being used. Rust takes a completely different approach which is based on "ownership".

Here’s a short summary of the concept of "ownership". In a Rust program, every value (like the value bound to a variable) has at most one "owner" at a given time. There is a "scope" associated with the "owner" of a value. When the owner of a value goes out of scope, the memory that was consumed by that value is freed, which means the value is dropped and is no longer accessible. This memory cleanup happens automatically, so we don’t need to manage this manually.

Sometimes, we don’t want or need to have ownership of a value in order to make use of it. In such a scenario, we can "borrow" the value of interest by creating a "reference" to it. That’s where the ampersand operator comes into play. Putting the ampersand operator in front of a variable name means that we’re creating a reference to the value that is owned by that variable. In other words, we’re borrowing the value that is owned by that variable.

At compile time, Rust runs a series of checks to verify that the code adheres to the rules of the system of ownership. If any of the checks fail then the program will not compile. If the compile time checks pass and a program successfully compiles, memory safety is ensured (with some caveats that I’ll address in a future episode).

From what I’ve gathered at this point, the memory safety offered by Rust (and the fact that this is handled automatically at compile time) is one of the biggest reasons why the Rust programming language has earned a reputation for reliability.

That’s a short summary of the concept of "ownership" in Rust and how this relates to memory management and memory safety. The book "The Rust Programming Language" has an entire chapter devoted to this topic which is titled "Understanding Ownership". If you’re interested in a comprehensive explanation of this topic then I’ll refer you to that resource.

Rust’s "ownership"-based approach to memory management is completely different to what I’m used to with Python. In Python, I rarely do anything to manually manage memory. When I have, it’s often been related to my use of DataFrames with the pandas package, such as deciding when to create a deep copy of a DataFrame, when to use the "del" keyword to delete a DataFrame, and deciding which data types to specify for various columns of data. In my experience, Python doesn’t really force me to think about memory management, but the tradeoff is that I often notice the memory usage for my programs can easily become bloated.

With Rust, I realize that I’m going to regularly be thinking about memory management in the sense of "ownership" and whether or not I need to own a given value or simply borrow a value via a reference. Honestly, I’m excited about this because I know having this low-level knowledge of memory management is going to help me take my software engineering skills to the next level.

Let’s make the concept of "ownership" a little more tangible by connecting this back to the practical code example we’re talking through. The statement we were last discussing involved calling the "dbg!" macro and passing it an argument of "&args". Here, we’re passing a reference to the value owned by the variable named "args" to the "dbg!" macro. Since we’re simply using the "dbg!" macro to print the value owned by the "args" variable, we don’t need to take ownership of this value – a reference is sufficient.

That was a lot of discussion initiated by the presence of just one character, the ampersand. The good thing is that this introduced us to a foundational concept in Rust. From now on, every time we see an ampersand operator in front of a variable name, we’ll know that this is a "reference" and that it relates to Rust’s system of "ownership".

Let’s keep going with the practical code example. At this point we’ve collected the command-line arguments into a vector of String values that is owned by the "args" variable. Now we want to get the actual values we care about out of that vector.

The first command-line argument listed in this vector is the name of the  Rust program binary itself. In our case, we want the very next command-line argument to be the path to the Markdown file. This means that the element at index 0 in the "args" vector is the name of the program binary and the element at index 1 will be the Markdown file path.

We have two new statements, still in the body of the "main" function. The first statement reads "let name_of_binary = ", followed by "&args[0]", and a trailing semicolon. The next statement reads "let file_path = ", followed by "&args[1]", and a trailing semicolon. With these two statements, we created variables to store the name of the program binary and the path to the Markdown file.

If you’re using the RustRover IDE you’ll see that these variables are annotated with the type "&String" (with a capital "S"). This makes sense because the command-line arguments are stored in a vector of String values, and we just created two variables that are references to the first two values in the vector. A variable that is a reference to a String value will have a type of "&String".

On the following two lines we have separate statements where we call the "dbg!" macro to print the values of the two variables we just created.  Currently, references to the variables are being passed as arguments to the "dbg!" macro, so there are ampersand characters in front of the variable names. I also tried passing the variable names to the "dbg!" macro without the ampersand characters with the thought that – these two variables are already references, so is it redundant to include the ampersand characters? Interestingly, the program compiles and runs in both of these scenarios. I don’t know exactly why, but this is an observation I’ll keep in mind because I’d like to know what’s going on here.

The last remaining statement in the "main" function involves calling the "run" function from the library crate. This line begins with the name of the package (which is listed in the "Cargo.toml" file) and is immediately followed by two colons and then the function name "run". Inside the parentheses following the function name "run", we have "file_path". "file_path" is a reference to a String value which is the path to the Markdown file. We’re passing this reference as an argument to the "run" function.

At this point, we’ve finished talking through all of the changes in the binary crate, "main.rs". Let’s jump over to the library crate, "lib.rs". The "run" function takes a single parameter, named "file_path". This parameter has a type annotation of "&String". This parameter has the same name as the variable we passed as an argument when we called the "run" function inside the "main" function. These two names could have been different – they’re just named identically for clarity and consistency. The type annotation of "&String" makes sense because when we call this function inside the "main" function, we pass a reference to a String value which is the path to the Markdown file.

The original statement with a hard-coded value for the "file_path" variable has been removed, so we now have a dynamic file path that is specified via a command-line argument.

Now, we’re finally at the point where we can compile and run our program. Since we’ve generalized the program to take the path to the Markdown file as a command-line argument, we can also test out a few scenarios that will cause our Rust program to panic. When a Rust program "panics", this means that it terminates immediately. For example, a bug in a Rust program will cause the program to panic.

When we use the command "cargo run" to compile and run a program, we use two hyphen characters to separate the command "cargo run" from the command-line arguments that follow.

For example, let’s open a command-line shell and run the command "cargo run -- ../data/musical_instruments.md". This musical instruments Markdown file is an example file that exists in the GitHub repo. In this command, we’re passing a single command-line argument to the program, which is the path to the Markdown file. After running this command, we see a multi-line message that includes the words "Compiling", "Finished", and "Running", followed by the output from the "dbg!" macro that we used to print values of several variables, and finally we see the extracted title of the Markdown file on the last line, as expected. Both standard output and standard error are displayed in our command-line shell.

Let’s redirect standard output and standard error to separate files so that we can see exactly what shows up in each of these. To do this, we run the same command as before, and now at the end we include the following: "1> stdout.txt 2> stderr.txt". The number 1 is the file descriptor for standard output and the number 2 is the file descriptor for standard error. If we open the "stdout.txt" file, we’ll see only the extracted title of the Markdown file, as expected. If we open "stderr.txt", we’ll see the rest of the information that we previously saw in the command-line shell, such as the outputs of the "dbg!" macro.

We know that our program runs successfully. Now, we’ll go through three scenarios that will cause our program to panic.

First, let’s run the command "cargo run" without any arguments. We see a message that includes the word "panicked" and the message "index out of bounds". This is what we’d expect because in our vector of command-line arguments, we can’t get the second element (which is supposed to be the path to the Markdown file) because the second element doesn’t exist. We didn’t provide any command-line arguments.

Next, let’s run the program for a Markdown file that does not exist. When we run the command "cargo run -- does_not_exist.md", we again see a message that includes the word "panicked", and in addition we see the messages "Could not read the file" and "No such file or directory". This is what we’d expect because we can’t read a non-existent file. Note that we actually have some control over the message printed here, since the message "Could not read the file" is what we passed to the "expect" method for the "read_to_string" function.

For our final panic scenario, we’ll run the program for a Markdown file that is completely empty and that exists in the GitHub repo. When we run the command "cargo run -- ../data/empty_file.md", we again see a message that includes the word "panicked", and now we see a message that says "File is empty". This is what we’d expect because we can’t read the first line of a completely empty file. As with the previous scenario, we have control over the message printed here because this is the message we passed to the "expect" method after trying to get the first line of the file.

Right now, we know the program is panicking in the three scenarios we just talked through, and we don’t necessarily want that. Allowing the program to panic isn’t a very graceful way to stop the program, and there’s also a lot of technical information being printed that we don’t necessarily need or want the user to see. Since we can anticipate the failure of certain operations (due to a missing command-line argument, a non-existent file, or an empty file), we can handle these issues more gracefully by using a "Result" enum, which is one of the key improvements to our program that we’ll talk about in the next episode.

That wraps up the second version of our practical code example for the topic of extracting text from a Markdown file. To recap, we talked about refactoring our program into a binary crate and a library crate to adhere to the concept of separation of concerns, we learned how to pass command-line arguments to our program, and we discussed the concept of "ownership" in a Rust program.

I hope this was helpful. You can find more details about the podcast on the website provided in the episode notes. This website includes a link to the relevant practical code examples for each episode.

Thanks for listening and stay tuned for the release of the next episode in which we’ll learn a cleaner approach for error handling.
